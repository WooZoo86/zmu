use register::Reg;
use condition::Condition;
use enum_set::EnumSet;

#[allow(non_camel_case_types)]
pub enum Op {
    ADC,
    ADDS { rm: Reg, rn: Reg, rd: Reg },
    ADD { rm: Reg, rdn: Reg },
    ADDS_imm { rn: Reg, rd: Reg, imm32: u32 },
    ADR,
    AND,
    ASR,
    B { cond: Condition, imm32: i32 },
    BIC,
    BKPT,
    BL { imm32: i32 },
    BLX { rm: Reg },
    BX { rm: Reg },
    CMN,
    CMP_imm { rn: Reg, imm32: u32 },
    CMP { rm: Reg, rn: Reg },
    CPS,
    CPY,
    DMB,
    DSB,
    EOR,
    ISB,
    LDM,
    LDMIA,
    LDMFD,
    LDR_imm { rt: Reg, rn: Reg, imm32: u32 },
    LDR_lit { rt: Reg, imm32: u32 },
    LDR_reg { rt: Reg, rn: Reg, rm: Reg },
    LDRB_imm,
    LDRB_reg,
    LDRH_imm,
    LDRH_reg,
    LDRSB_reg,
    LDRSH_reg,
    LSL_imm,
    LSL_reg,
    LSR_imm,
    LSR_reg,
    MOV_reg { rd: Reg, rm: Reg, setflags: bool},
    MOV_imm { rd: Reg, imm32: u32 },
    MRS,
    MRS_reg,
    MUL,
    MVN_reg,
    NOP,
    ORR,
    POP { registers: EnumSet<Reg> },
    PUSH { registers: EnumSet<Reg> },
    REV,
    REV16,
    REVSH,
    ROR,
    RSB,
    SBC,
    SEV,
    STM,
    STMIA,
    STMEA,
    STR_imm,
    STR_reg,
    STRB_imm,
    STRB_reg,
    STRH_imm,
    STRH_reg,
    SUBS_imm { rd: Reg, rn: Reg, imm32: i32 },
    SUBS_reg { rm: Reg, rn: Reg, rd: Reg },
    SUB_SP_imm,
    SVC,
    SXTB,
    SXTH,
    TST,
    UDF,
    UXTB,
    UXTH,
    WFE,
    WFI,
    YIELD,
}
